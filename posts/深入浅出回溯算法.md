---
title: "深入浅出回溯算法：通俗易懂 + 代码详解"
excerpt: "回溯算法讲解"
date: "2025-03-26"
author: "Ryan"
category: "算法"
tags: ["算法"]
imageUrl: ""
---

## 什么是回溯算法

回溯（Backtracking）是一种暴力搜索方法，常用于解决排列、组合、子集、图遍历等问题。
它的本质是 **递归 + 试探 + 回退**：

1. **递归**：尝试所有可能的解。
2. **试探**：当前选择是否符合条件？
3. **回退**：如果当前选择不符合，撤销选择，尝试别的可能性。

你可以把回溯算法想象成一个聪明但有点啰嗦的尝试过程，它会穷举所有可能的方案，找到符合条件的答案。

例如，在游戏闯关（探索迷宫）中：

想象你在一个迷宫里找出口，每个路口可以选择向左、向右、向前。

- 你不知道出口在哪，所以只能每条路都试一试。
- 走到死路了，就退回上一步，换一条路试试。
- 如果某条路能走通，就继续前进，直到找到出口。

回溯就像一个不断 **尝试 → 撤销 → 再尝试** 的过程，直到找到所有可行的路线！

---

## 回溯的基本框架

回溯算法通常以**树形结构**进行搜索，每个节点代表一种选择。

**标准回溯模板：**

```ts
function backtrack(路径, 选择列表) {
  if (满足结束条件) {
    记录结果;
    return;
  }

  for (选择 of 选择列表) {
    做选择;
    backtrack(新的路径, 新的选择列表);
    撤销选择;
  }
}
```

- **路径**：已经做出的选择。
- **选择列表**：当前可以做的选择。
- **结束条件**：是否满足题目要求。

---

## 经典例子：全排列

**题目**：给定一个不含重复数字的数组 `nums`，返回它的所有可能的排列。

**代码实现：**

```ts
function permute(nums: number[]): number[][] {
  const res: number[][] = [];
  const path: number[] = [];
  const used: boolean[] = new Array(nums.length).fill(false);

  function backtrack() {
    if (path.length === nums.length) {
      res.push([...path]);
      return;
    }

    for (let i = 0; i < nums.length; i++) {
      if (used[i]) continue;

      path.push(nums[i]);
      used[i] = true;
      backtrack();
      path.pop();
      used[i] = false;
    }
  }

  backtrack();
  return res;
}

console.log(permute([1, 2, 3]));
```

---

**代码拆解**

**递归终止的条件**

```ts
if (path.length === nums.length) {
  res.push([...path]);
  return;
}
```

- 当 `path` 的长度等于 `nums` 长度，说明已经选完所有元素，构成一个完整排列。
- 复制 `path` 到 `res`，然后返回，不再继续递归。

**`for` 循环遍历所有可能的选择**

```ts
for (let i = 0; i < nums.length; i++) {
  if (used[i]) continue;
```

- 我们要尝试每个数是否能放入 `path`。
- 如果 `nums[i]` 已经在 `path` 里了（`used[i] === true`），就跳过。

**选择当前数字，递归进入下一层**

```ts
path.push(nums[i]); // 选择 nums[i]
used[i] = true; // 标记为已使用
backtrack(); // 递归进入下一层
```

- 选择 `nums[i]` 并加入 `path`，然后进入下一层递归，继续选择下一个数字。

**回溯（撤销选择）**

```ts
path.pop(); // 撤销选择
used[i] = false; // 标记为未使用
```

- 撤销 `path` 的最后一个数字，相当于回退一步，尝试其他可能。
- 恢复 `used[i]` 的状态，让 `nums[i]` 重新可用。

---

**递归执行的过程**

```scss
(开始)
 ├── 1
 │   ├── 2
 │   │   ├── 3 ✅ [1,2,3]
 │   │   ├── 回溯（撤销3）
 │   ├── 3
 │   │   ├── 2 ✅ [1,3,2]
 │   │   ├── 回溯（撤销2）
 │   ├── 回溯（撤销1）
 ├── 2
 │   ├── 1
 │   │   ├── 3 ✅ [2,1,3]
 │   │   ├── 回溯（撤销3）
 │   ├── 3
 │   │   ├── 1 ✅ [2,3,1]
 │   │   ├── 回溯（撤销1）
 │   ├── 回溯（撤销2）
 ├── 3
 │   ├── 1
 │   │   ├── 2 ✅ [3,1,2]
 │   │   ├── 回溯（撤销2）
 │   ├── 2
 │   │   ├── 1 ✅ [3,2,1]
 │   │   ├── 回溯（撤销1）
 │   ├── 回溯（撤销3）
```

最终结果：

```ts
[[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]
```

---

## 总结

**回溯的核心思想**：

1. **做选择**：从 `nums` 中选一个未使用的数，加入 `path`。
2. **递归进入下一层**：继续选择下一个数。
3. **回溯（撤销选择）**：撤销上一步的选择，恢复状态，尝试其他可能。

**适用于所有排列/组合问题：**

- **排列**：`permute([1,2,3]) → n!`
- **组合**：`C(n,k)` → 选出 `k` 个数的所有组合。
- **子集**：所有可能的选取方式。
- **数独求解、八皇后问题** 也都可以用回溯解决！
